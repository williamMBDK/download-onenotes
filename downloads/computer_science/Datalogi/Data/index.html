<html lang="en-US"><head>
		<title>Data</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta name="created" content="2019-01-07T21:26:00.0000000">
	</head>
	<body data-absolute-enabled="true" style="font-family:Calibri;font-size:11pt"><h1>Data</h1>
		<div style="position:absolute;left:48px;top:115px;width:720px">
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Picking a datastructure</span></p>
			<ul>
				<li>KISS: "Keep It Simple, Stupid."</li>
				<li>Avoid dynamic memory</li>
			</ul>
			<br>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Generelt</span></p>
			<ul>
				<li><p style="margin-top:0pt;margin-bottom:0pt">Dynamic memory</p>
				<ul>
					<li>Allocation</li>
					<li>Access</li>
				</ul>
				</li>
				<li>Static memory</li>
				<li><p style="margin-top:0pt;margin-bottom:0pt">Paralel arrays</p>
				<ul>
					<li>Ex. One way to do a linked list, where instead of keeping a next point, you keep a second array, which has the index of the next element.</li>
				</ul>
				</li>
			</ul>
			<br>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Primitive datatyper</span></p>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Typer</span></p>
			<ul>
				<li>Integer</li>
				<li>Float</li>
				<li>Double<span style="font-weight:bold">t</span></li>
				<li>Long</li>
				<li>Boolean</li>
			</ul>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Underflow</span></p>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Overflow</span></p>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Signed (-)</span></p>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Unsigned (+)</span></p>
			<ul>
				<li>Byte[]</li>
				<li>New BigInteger(String value);</li>
			</ul>
			<br>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Avancerede datatyper</span></p>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">String</span></p>
			<ul>
				<li>string concatination</li>
				<li>Palindrome</li>
			</ul>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Array (static)</span></p>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Lister (dynamic)</span></p>
			<ul>
				<li>List (List, ArrayList, Vector)</li>
				<li>N-dimensionel</li>
				<li><p style="margin-top:0pt;margin-bottom:0pt">List concatenation</p>
				<ul>
					<li>System.arraycopy() (copy to array)</li>
					<li>Stream.of(a, b).flatMap(Stream::of).toArray();</li>
					<li>IntStream.concat(Arrays.stream(a),Arrays.stream(b)).toArray();</li>
				</ul>
				</li>
				<li><p style="margin-top:0pt;margin-bottom:0pt">List generering / List comprehension</p>
				<ul>
					<li>IntStream.range(0,N).map(i-&gt;f(i)).toArray();</li>
				</ul>
				</li>
				<li><p style="margin-top:0pt;margin-bottom:0pt">Sublist</p>
				<ul>
					<li>Arrays.copyOfRange()</li>
					<li>List.sublist()</li>
				</ul>
				</li>
			</ul>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Bitset (array of booleans)</span></p>
			<ul>
				<li><span style="font-style:italic">BitSet</span></li>
			</ul>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Bitmask</span></p>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Tupler</span> </p>
			<ul>
				<li>Lister der ikke kan ændres</li>
			</ul>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Set</span></p>
			<ul>
				<li>Set&lt;String&gt; hash_Set = new HashSet&lt;String&gt;();</li>
				<li>Bruger hashtable</li>
			</ul>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold;font-style:italic">Linked</span><span style="font-weight:bold"> -list -set -dictionary</span></p>
			<ul>
				<li><p style="margin-top:0pt;margin-bottom:0pt"><span style="font-style:italic">LinkedHashmap</span></p>
				<ul>
					<li>Gemmer rækkefølgen for put I linkedlist.</li>
				</ul>
				</li>
			</ul>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Queue / Køer</span></p>
			<ul>
				<li>ArrayDeque&lt;ArrayList&lt;Integer&gt;&gt; que = newArrayDeque&lt;&gt;()</li>
				<li>FIFO</li>
				<li><p style="margin-top:0pt;margin-bottom:0pt">Prioritetskø (Virker vha. Hob)</p>
				<ul>
					<li>PriorityQueue / TreeSet (sortedset)</li>
				</ul>
				</li>
			</ul>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Stack</span></p>
			<ul>
				<li>LIFO</li>
			</ul>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Deque</span></p>
			<ul>
				<li>Double ended queue</li>
			</ul>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Objekter</span></p>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Hash table / hashmap</span></p>
			<ul>
				<li><p style="margin-top:0pt;margin-bottom:0pt">pigeon-hole principle (if contains NHASH + 1 words --&gt; one pair of them will yield the same function value) (collision)</p>
				<ul>
					<li><p style="margin-top:0pt;margin-bottom:0pt">Avoid by</p>
					<ul>
						<li>Linked list of hashmatches</li>
						<li>Good hashfunction</li>
					</ul>
					</li>
				</ul>
				</li>
				<li><p style="margin-top:0pt;margin-bottom:0pt">Function that returns unique number corresponding to index of an object.</p>
				<ul>
					<li>Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</li>
					<li>Bruger hashtable</li>
				</ul>
				</li>
			</ul>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Dictionary (associative array)</span></p>
			<br>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Datastrukturer</span></p>
			<ul>
				<li>Arrays</li>
				<li>Linked lists</li>
				<li>Stacks</li>
				<li>Queues</li>
				<li>Deques</li>
			</ul>
			<br>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Abstrakte Datastrukturer</span></p>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Grafer</span></p>
			<ul>
				<li><p style="margin-top:0pt;margin-bottom:0pt">Repræsentation</p>
				<ul>
					<li><p style="margin-top:0pt;margin-bottom:0pt">Nabomatrix: tabel af n * n, hvor n = antal knuder (Adjacency Matrix)</p>
					<ul>
						<li>It is sometimes helpful to use the fact that the (i,j) entry of the adjacency matrix raised to the k-th power gives the number of paths from vertex i to vertex j consisting of exactly k edges.</li>
					</ul>
					</li>
					<li><p style="margin-top:0pt;margin-bottom:0pt">Nabolister: n lister I en liste som indeholder lister med naboer og evt. deres vægte (adjacency list), linjedlists</p>
					<ul>
						<li>Class --&gt; objekt --&gt; refererende lister</li>
						<li>Directed: store only the edges in one direction, keep a seperate list of incoming and outgoing arcs, or denote the direction of each arc in the list. </li>
					</ul>
					</li>
					<li>Edge list (liste med edges (2*n) og evt. Vægte (3*n))</li>
					<li>Implicit</li>
				</ul>
				</li>
				<li>Graf uden vægtning med eller uden retning</li>
				<li>Vægtet graf med eller uden retning</li>
				<li>Implicit graf</li>
				<li>Simpel graph (no selfloop, no repeating edges)</li>
				<li>Multigraph (selfloops or repeating edges)</li>
				<li>Sparse and dense graphs</li>
				<li>Connected graph</li>
				<li>Strongly connected graph</li>
				<li>Union find</li>
				<li><p style="margin-top:0pt;margin-bottom:0pt">Planar graph:</p>
				<ul>
					<li>Can be drawn without edges crossing. Min nodes for not planar: 5</li>
				</ul>
				</li>
				<li><p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Træer</span></p>
				<ul>
					<li>Segment træer</li>
					<li>Fenwick træer</li>
					<li>State space tree</li>
					<li>Heap / hob (min / max)</li>
					<li><p style="margin-top:0pt;margin-bottom:0pt">Minimum spanning tree</p>
					<ul>
						<li><p style="margin-top:0pt;margin-bottom:0pt">Prims algoritme</p>
						<ul>
							<li>changing any element in a tree requires complete recalculation</li>
							<li>Not working on directed graphs</li>
						</ul>
						</li>
						<li>Kruskals algoritme</li>
						<li>Given: an undirected, connected graph with weighted edges</li>
						<li>A spanning tree of a graph is any sub-graph which is a connected tree (i.e., there exists a path between any nodes of the original graph which lies entirely in the sub-graph).</li>
						<li>A minimal spanning tree is a spanning tree which has minimal `cost' (where cost is the sum of the weights of the edges in the tree).</li>
					</ul>
					</li>
					<li><p style="margin-top:0pt;margin-bottom:0pt">Binary tree</p>
					<ul>
						<li>Binary indexed tree</li>
						<li><p style="margin-top:0pt;margin-bottom:0pt">Binary search tree (weigted, ordered, rooted)</p>
						<ul>
							<li>Splays tree</li>
							<li>Red black trees</li>
							<li>Treaps</li>
							<li>B-trees</li>
							<li>AVL</li>
						</ul>
						</li>
						<li>Balanced binary search tree</li>
						<li><p style="margin-top:0pt;margin-bottom:0pt">Binary heap</p>
						<ul>
							<li><p style="margin-top:0pt;margin-bottom:0pt">Representation: </p>
							<ul>
								<li>List: In this representation, the children of the node at position x are 2x and 2x+1 (assuming 1 based indexing), and the parent of x is truncate(x/2).</li>
								<li>Graph with pointers</li>
							</ul>
							</li>
							<li>"What's the smallest thing?" in a collection of dynamic values. It's a compact representation and quick to compute. An example of a location where this can be helpful is Dijkstra's algorithm.</li>
						</ul>
						</li>
					</ul>
					</li>
					<li><p style="margin-top:0pt;margin-bottom:0pt">B-tree</p>
					<ul>
						<li>Binary but can have more than 2 children</li>
					</ul>
					</li>
					<li>Random tree</li>
					<li><p style="margin-top:0pt;margin-bottom:0pt">Tries</p>
					<ul>
						<img alt="Machine generated alternative text:

" width="140.5" height="96" src="./image1.gif" data-src-type="image/gif" data-fullres-src="https://graph.microsoft.com/v1.0/users('115170e9-95f0-4986-9952-a244e9167b35')/onenote/resources/1-7650810a1e4346b7879e6d11e281c1b1!1-13a309be-b2d0-4733-9cd3-46801d055004/$value" data-fullres-src-type="image/gif">
						<li>Siblings and children.</li>
						<li>Used to store collection of sequenses</li>
						<li>Rooted</li>
						<li>Does there exist a sequence (word, multi-digit number, or other type) that starts with this?</li>
						<li><p style="margin-top:0pt;margin-bottom:0pt">Variations</p>
						<ul>
							<li>If your list may contain two words, one of which is a prefix of the other, you have to add a flag at each node which says "A word ends here." For example, if you wanted to also have "CA" in your trie, it would have to be flagged.</li>
							<li>It sometimes helps to keep the linked list of children in sorted order. This increases the time to build the trie, but decreases the time to search it.</li>
							<li>If you have many words with similar prefixes but unique endings, it is sometimes helpful to put "special" nodes that stand for a sequence themselves. For example, if you want to represent "CARTING," "COBBLER," and "CATCHING," memory constraints may make it more reasonable to represent a "RTING," "BBLER," and "TCHING" node. Note that this increases the complexity dramatically.</li>
						</ul>
						</li>
					</ul>
					</li>
				</ul>
				</li>
				<li>Forest</li>
				<li>Dag</li>
				<li>Complete graph</li>
				<li><p style="margin-top:0pt;margin-bottom:0pt">Bipartite graph</p>
				<ul>
					<li>Ingen kredse af ulige længde</li>
					<li>n^2/4 er max antal kanter</li>
				</ul>
				</li>
				<li>Transpose graph</li>
				<br>
			</ul>
			<p style="margin-top:0pt;margin-bottom:0pt">For a simple, connected, planar graph with v vertices and e edges and f faces, the following simple conditions hold for v ≥ 3:</p>
			<p style="margin-top:0pt;margin-bottom:0pt">Theorem 1. e ≤ 3v − 6;</p>
			<p style="margin-top:0pt;margin-bottom:0pt">Theorem 2. If there are no cycles of length 3, then e ≤ 2v − 4.</p>
			<p style="margin-top:0pt;margin-bottom:0pt">Theorem 3. f ≤ 2v − 4.</p>
			<br>
			<br>
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-weight:bold">Andet</span></p>
			<ul>
				<li><p style="margin-top:0pt;margin-bottom:0pt">Classes</p>
				<ul>
					<li style="list-style-type:circle">Constructor</li>
				</ul>
				</li>
				<li>Subclass</li>
			</ul>
		</div>
		<!-- InkNode is not supported -->
		<div style="position:absolute;left:840px;top:979px;width:624px">
			<p style="margin-top:0pt;margin-bottom:0pt"><span style="font-family:Verdana;color:black">If N is the number of vertices, M the number of edges, and&nbsp;</span><span style="font-family:Verdana;color:black;font-style:italic">d&nbsp;</span><sub style="font-family:Verdana;color:black;font-style:italic">max</sub><span style="font-family:Verdana;color:black">&nbsp;the maximum degree of a node, the following table summarizes the differences between the representations:</span></p>
			<br>
			<table style="border:1px solid;border-collapse:collapse">
				<tbody><tr>
					<td style="border:1px solid">Efficiency</td>
					<td style="border:1px solid;text-align:center">Edge List</td>
					<td style="border:1px solid;text-align:center">Adj Matrix</td>
					<td style="border:1px solid;text-align:center">Adj List</td>
				</tr>
				<tr>
					<td style="border:1px solid">Space</td>
					<td style="border:1px solid;text-align:center">2xM</td>
					<td style="border:1px solid;text-align:center">N<sup>2</sup></td>
					<td style="border:1px solid;text-align:center">2xM</td>
				</tr>
				<tr>
					<td style="border:1px solid">Adjacency Check</td>
					<td style="border:1px solid;text-align:center">M</td>
					<td style="border:1px solid;text-align:center">1</td>
					<td style="border:1px solid;text-align:center"><span style="font-style:italic">d&nbsp;</span><sub style="font-style:italic">max</sub></td>
				</tr>
				<tr>
					<td style="border:1px solid">List of Adj Vertices</td>
					<td style="border:1px solid;text-align:center">M</td>
					<td style="border:1px solid;text-align:center">N</td>
					<td style="border:1px solid;text-align:center"><span style="font-style:italic">d&nbsp;</span><sub style="font-style:italic">max</sub></td>
				</tr>
				<tr>
					<td style="border:1px solid">Add Edge</td>
					<td style="border:1px solid;text-align:center">1</td>
					<td style="border:1px solid;text-align:center">1</td>
					<td style="border:1px solid;text-align:center">1</td>
				</tr>
				<tr>
					<td style="border:1px solid">Delete Edge</td>
					<td style="border:1px solid;text-align:center">M</td>
					<td style="border:1px solid;text-align:center">2</td>
					<td style="border:1px solid;text-align:center">2x<span style="font-style:italic">d&nbsp;</span><sub style="font-style:italic">max</sub></td>
				</tr>
			</tbody></table>
		</div>
		<!-- InkNode is not supported -->
	

</body></html>